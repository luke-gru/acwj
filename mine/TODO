TODO
====

Functional
----------
* Get `1-1` working as intended, right now `-` right before a digit is scanned
as part of the INTLIT (workarounds all over source code of compiler)
* Allow structs as function parameters and local variables (needs more testing)
* Allow assignment declaration as init value in `for` stmt `for (int i = 0;;`)
* Put string literals in read-only memory
* Allow structs to be returned (see what gcc does, caller allocates stack
space for the function)
* Allow structs to be given as arguments (see what gcc does)

Bugs
----
* expression list as RHS of var declaration doesn't compile (see
test/compiler/assignment_expressions2.c
* compound assignment operators (+=, -=) don't check types of arguments in binexpr()

Optimizations
-------------
* Better register allocation/spilling (linear scan)
* Omit the frame pointer as micro-optimization, use stack pointer offsets instead
* Various register optimizations

Would Be Nice
-------------
* Output debug information during compilation
* Add static local variables, only initialized during first call to function
(see what gcc does)

IR:
---

* do break/continues in terms of gotos, need to keep
track of cur_loop bb and patch all the breaks that way
when we end the cur_loop. For continues, it's just a goto
to cur_loop. [DONE]

* Implement A_GOTO and A_LABEL (don't need IR_LABEL I
don't think anyway). [later]

* Implement switch statements (HARD, don't know what to do here).
[later]

* Implement A_STRLIT, not sure if cg.c should take take of dedup
or IR should, but I'm leaning towards the latter. IR_MEM could
be an IRValue, but then we'd need non basic block structures before the
basic blocks for all data. [mostly done, need to add labels for data section
and dedup data section]

* Implement A_ADDR

* Implement A_DEREF

* Implement A_NEGATE

* Implement A_TERNARY [DONE]

ASM:
----
* Get simple IR compiling to asm (return (0)) [DONE]
* Get assignment, local variable loading, immediate loading and if branches
working [DONE]

Improvements/Concerns
---------------------

The IR that I'm generating is fine, but I'm making a lot of transformations
that shouldn't occur until a later lowering phase. (ex: subtraction must work
on temporaries so I'll turn both e->left and e->right into temps (regs). Now I
can't constant fold! The high-level IR should be just that, high-level and
not making these decisions.

How should the high-level IR be represented? I think TAC is fine, if in SSA
form with basic blocks and PHI functions.

Then we'll do a separate lowering phase to make for easier asm generation.

Optimizations:
SSA Form:
* constant folding (easy)
* Common Subexpression Elimination (CSE)
* Global Value Numbering (advanced CSE)

Register Allocations
--------------------
